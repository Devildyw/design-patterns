# 设计模式--结构型模式之享元模式

> 运用共享技术有效地支持大量细粒度对象的复用

> spring的常量池、数据库连接池、缓冲池等等这些都是享元模式的应用
>
> 比如：我们每次创建字符串对象时，如果每次都创建一个新的字符串对象的话，内存开销会很大，所以如果第一次创建了字符串对象“七夕“，下次再创建相同的字符串”七夕“时，只是把它的引用指向”七夕“，这样就实现了”七夕“字符串再内存中的共享。

**享元拆开来讲，享，即共享，元，可以理解为元数据，内存当中的数据，对象。看来是共享对象喽**

## 模式动机

面向对象技术可以很好地解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。当对象数量太多时，将导致运行代价过高，带来性能下降等问题。

- 享元模式正是为解决这一类问题而诞生的。享元模式通过共享技术实现相同或相似对象的重用。
- 在享元模式中可以共享的相同内容称为内部状态(IntrinsicState)，而那些需要外部环境来设置的不能共享的内容称为外部状态(Extrinsic State)，由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的。
- 在享元模式中通常会出现工厂模式，需要创建一个享元工厂来负责维护一个享元池(Flyweight Pool)用于存储具有相同内部状态的享元对象。
- 在享元模式中共享的是享元对象的内部状态，外部状态需要通过环境来设置。在实际使用中，能够共享的内部状态是有限的，因此享元对象一般都设计为较小的对象，它所包含的内部状态较少，这种对象也称为细粒度对象。享元模式的目的就是使用共享技术来实现大量细粒度对象的复用。

## 模式定义

享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。

## 模式结构

享元模式包含如下角色：

- **Flyweight: 抽象享元类** 定义了享元对象需要实现的公共操作方法。在该方法中会使用一个状态作为输入参数，也叫外部状态。
- **ConcreteFlyweight: 具体享元类** 能够复用享元工厂内部状态并实现享元类公共操作的具体实现类。
- **UnsharedConcreteFlyweight: 非共享具体享元类** 不复用享元工厂内部状态，但实现享元类的具体实现类。
- **FlyweightFactory: 享元工厂类** 管理一个享元对象类的缓存池

![../_images/Flyweight.jpg](https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208291310426.jpeg)

## 时序图

![../_images/seq_Flyweight.jpg](https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208291310753.jpeg)

## 代码分析

享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 *Circle* 对象。

对于相同颜色不同坐标的圆，我们可以将原有颜色的圆复用，这样可以减少很多内存空间，如果不进行复用而是每个坐标每个颜色圆都创建新的对象，那么该示例中就会出现20个新增对象。

**抽象享元类** 创建一个Shape接口。

```java
public interface Shape {
    void draw();
}
```

**具体享元类** 创建实现接口的实体类。

```java
public class Circle implements Shape {
    //颜色
    private String color;

    //x坐标
    private int x;

    //y坐标
    private int y;

    //半径
    private int radius;

    public Circle(String color) {
        this.color = color;
    }

    public void setX(int x) {
        this.x = x;
    }

    public void setY(int y) {
        this.y = y;
    }

    public void setRadius(int radius) {
        this.radius = radius;
    }

    @Override
    public void draw() {
        System.out.println("Circle: Draw()[" +
                "color='" + color + '\'' +
                ", x=" + x +
                ", y=" + y +
                ", radius=" + radius +
                ']');
    }
}
```

**享元工厂类** 创建一个工厂，生成基于给定信息的实体类的对象。

```java
public class ShapeFactory {
    //创建一个缓存池
    private static final HashMap<String, Shape> circleMap = new HashMap<>();

    /**
     * 获取对象
     * @param color 颜色
     * @return Shape
     */
    public static Shape getCircle(String color){
        //从缓存池中获取 防止每次都生成新的对象导致内存中对象数量太多(节约内存空间)
        Circle circle = (Circle) circleMap.get(color);

        //如果缓冲池中没有 才去创建新的对象 并且将创建好的对象加入缓存池中
        if (circle == null){
            circle = new Circle(color);
            circleMap.put(color,circle);
            System.out.println("Creating circle of color : " + color);
        }
        return circle;
    }
}
```

**客户端** 使用该工厂，通过传递颜色信息来获取实体类的对象。

```java
public class Client {
    private static final String colors[] = {"Red", "Green", "Blue", "White", "Black"};

    public static void main(String[] args) {
        for (int i = 0; i < 20; i++) {
            Circle circle = (Circle) ShapeFactory.getCircle(getRandomColor());
            circle.setX(getRandomX());
            circle.setY(getRandomY());
            circle.setRadius(100);
            circle.draw();
        }
    }

    /**
     * 获取随机颜色
     * @return String
     */
    private static String getRandomColor() {
        return colors[(int) (Math.random() * colors.length)];
    }

    /**
     * 获取随机x坐标
     * @return int
     */
    private static int getRandomX() {
        return (int) (Math.random() * 100);
    }

    /**
     * 获取随机y坐标
     * @return int
     */
    private static int getRandomY() {
        return (int) (Math.random() * 100);
    }
}
```

**结果**

![image-20220829131943337](https://ding-blog.oss-cn-chengdu.aliyuncs.com/images/202208291319413.png)

可以发现我们花了20个不同坐标不同颜色的圆，但实际上只创建了5个对象。

## 模式分析

享元模式是一个考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能。

享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。

享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态(Internal State)和外部状态(External State)。

- **内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享。**
- **外部状态是随环境改变而改变的、不可以共享的状态。**享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。

## 实例

spring的常量池、数据库连接池、缓冲池等；英雄联盟中，一台服务器要连接多个客户端（多个玩家），如果每个玩家进去地图都要创建对象，那对象将无数啊。。。。。所以这里要使用享元模式，将地图对象减少到几个实例。

## 优点

享元模式的优点

- 享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。
- 享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。

## 缺点

享元模式的缺点

- 享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。
- 为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。

## 适用环境

在以下情况下可以使用享元模式：

- 一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。
- 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。
- 使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。

## 模式应用

享元模式在编辑器软件中大量使用，如在一个文档中多次出现相同的图片，则只需要创建一个图片对象，通过在应用程序中设置该图片出现的位置，可以实现该图片在不同地方多次重复显示。

## 模式扩展

单纯享元模式和复合享元模式

- 单纯享元模式：在单纯享元模式中，所有的享元对象都是可以共享的，即所有抽象享元类的子类都可共享，不存在非共享具体享元类。
- 复合享元模式：将一些单纯享元使用组合模式加以组合，可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。

享元模式与其他模式的联用

- 在享元模式的享元工厂类中通常提供一个静态的工厂方法用于返回享元对象，使用简单工厂模式来生成享元对象。
- 在一个系统中，通常只有唯一一个享元工厂，因此享元工厂类可以使用单例模式进行设计。
- 享元模式可以结合组合模式形成复合享元模式，统一对享元对象设置外部状态。

## 总结

- 享元模式运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用，它是一种对象结构型模式。
- 享元模式包含四个角色：抽象享元类声明一个接口，通过它可以接受并作用于外部状态；具体享元类实现了抽象享元接口，其实例称为享元对象；非共享具体享元是不能被共享的抽象享元类的子类；享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中。
- 享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态和外部状态。其中内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享；外部状态是随环境改变而改变的、不可以共享的状态。
- 享元模式主要优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份；其缺点是使得系统更加复杂，并且需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。
- 享元模式适用情况包括：一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费；对象的大部分状态都可以外部化，可以将这些外部状态传入对象中；多次重复使用享元对象。